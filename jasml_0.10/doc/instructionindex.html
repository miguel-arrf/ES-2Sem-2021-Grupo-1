<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- InstanceBegin template="/Templates/jasml_template.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="keywords" content="java assemble assembling compiler decompiler jasmin byte code macro instrcution java virtual machine instruction">
<!-- InstanceBeginEditable name="doctitle" -->
<title>Jasml - Java Macro Instruction Index</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" --><!-- InstanceEndEditable -->
<link href="style.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.STYLE3 {font-size: small}
-->
</style>
</head>

<body>
<h1 align="center" ><strong><a href="index.html" class="NOUnderLine">Jasml</a> </strong></h1>
<h1 align="center" ><strong>The Java Assembling Language </strong></h1>
<hr>
<table width="100%" border="0" cellspacing="2" cellpadding="6">
  <tr valign="top">
    <td width="230" nowrap="nowrap" class="TableRightBorder"> <p><a href="index.html"><strong>Jasml Home</strong></a></p>
      <p> 
             <a href="userguide.html"><strong>User Guide </strong></a>          </p>
      <ul>
          <li><a href="userguide.html#gui_ins" class="NOUnderLine">Installation</a></li>
      </ul>
      
      
        <ul>
          <li><a href="userguide.html#gui_com" class="NOUnderLine">Command Line Parameters </a></li>
        </ul>
      
      
        <p><a href="example.html"><strong>A Simple Example</strong></a></p>
        <a href="syntax.html"><strong>Jasml Syntax </strong></a>
      
      
        <ul>
          <li><a href="syntax.html#min" class="NOUnderLine">Minor and Major versions</a></li>
        </ul>
      
      
        <ul>
          <li><a href="syntax.html#cla" class="NOUnderLine">Class or Interface Definitions</a></li>
        </ul>
      
      
        <ul>
          <li><a href="syntax.html#fie" class="NOUnderLine">Field Definitions</a></li>
        </ul>
      
      
        <ul>
          <li><a href="syntax.html#met" class="NOUnderLine">Methods Declarations </a></li>
        </ul>
      
      
        <ul>
          <li><a href="syntax.html#cla_att" class="NOUnderLine">Class Attribute Declarations</a></li>    
        </ul>
               <ul>
          <li><a href="syntax.html#num" class="NOUnderLine">Numbers Strings and Chars</a></li>
        </ul>   <ul>
          <li><a href="syntax.html#com" class="NOUnderLine">Comments</a></li>
        </ul>
        <p><a href="syntax_attr.html"><strong>Attributes </strong></a></p>
        <p><a href="syntax_instr.html"  ><strong>Java Macro Instructions</strong></a></p>
        <p><a href="instructionindex.html"><strong>Java Macro Instruction Index </strong></a> </p>
		<p><a href="javadoc/index.html"><strong>Javadoc</strong></a> </p>
		<p><a href="download.html"><strong>Download</strong></a> </p>
		<p>&nbsp;</p>
		<p><a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=168010&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
</p>
	<p>&nbsp;</p></td>
    <td><!-- InstanceBeginEditable name="content" -->
	<p class="PageTitle"> Java Macro Instruction Index</p>
	<p> The following are index of Java Macro Instruction Index, copied from <a href="http://java.sun.com/docs/books/jls/"> The Java Virtual Machine Specification</a>.</p>
	<br>
	<br>
	<p><span class='InstructionTitle'>Name</span> : nop</p>
<p><span class='InstructionTitle'>Opcode</span> : 0(0x0)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Do nothing</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>nop</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>No change</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Do nothing.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aconst_null</p>
<p><span class='InstructionTitle'>Opcode</span> : 1(0x1)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push null</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aconst_null</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., null</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the null object reference onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The Java virtual machine does not mandate a concrete value for null.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_m1</p>
<p><span class='InstructionTitle'>Opcode</span> : 2(0x2)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant -1</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., -1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant -1 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush -1 , except that the operand -1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 3(0x3)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 0</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 0</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 0 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 0 , except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 4(0x4)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 1</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 1 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 1 , except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 5(0x5)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 2</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 2</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 2 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 2 , except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 6(0x6)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 3</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 3</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 3 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 3 , except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_4</p>
<p><span class='InstructionTitle'>Opcode</span> : 7(0x7)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 4</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_4</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 4</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 4 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 4 , except that the operand 4 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iconst_5</p>
<p><span class='InstructionTitle'>Opcode</span> : 8(0x8)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push int constant 5</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iconst_5</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 5</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the int constant 5 onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This instructions is equivalent to bipush 5 , except that the operand 5 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lconst_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 9(0x9)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push long constant</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lconst_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 0</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the long constant0 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lconst_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 10(0xa)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push long constant</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lconst_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the long constant 1 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fconst_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 11(0xb)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fconst_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 0</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the float constant 0.0 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fconst_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 12(0xc)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fconst_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the float constant 1.0 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fconst_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 13(0xd)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fconst_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 2</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the float constant 2.0 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dconst_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 14(0xe)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dconst_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 0</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the double constant 0.0  onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dconst_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 15(0xf)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dconst_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., 1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Push the double constant 1.0 onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : bipush</p>
<p><span class='InstructionTitle'>Opcode</span> : 16(0x10)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push byte</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>bipush</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The immediate byte is sign-extended to an int value. That value is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : sipush</p>
<p><span class='InstructionTitle'>Opcode</span> : 17(0x11)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push short</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>sipush</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The immediate unsigned byte1 and byte2 values are assembled into an intermediate short where the value of the short is (byte1 << 8) | byte2. The intermediate value is then sign-extended to an int value. That value is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ldc</p>
<p><span class='InstructionTitle'>Opcode</span> : 18(0x12)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push item from runtime constant pool</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ldc</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be a valid index into the runtime constant pool of the current class. The runtime constant pool entry at index either must be a runtime constant of type int or float, or must be a symbolic reference to a string literal.<br>If the runtime constant pool entry is a runtime constant of type int or float, the numeric value of that runtime constant is pushed onto the operand stack as an int or float, respectively.<br>Otherwise, the runtime constant pool entry must be a reference to an instance of class String representing a string literal. A reference to that instance, value, is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The ldc instruction can only be used to push a value of type float taken from the float value set because a constant of type float in the constant pool must be taken from the float value set.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ldc_w</p>
<p><span class='InstructionTitle'>Opcode</span> : 19(0x13)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push item from runtime constant pool (wide index)</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ldc_w</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are assembled into an unsigned 16-bit index into the runtime constant pool of the current class, where the value of the index is calculated as (indexbyte1 << 8) | indexbyte2. The index must be a valid index into the runtime constant pool of the current class. The runtime constant pool entry at the index either must be a runtime constant of type int or float, or must be a symbolic reference to a string literal.<br>If the runtime constant pool entry is a runtime constant of type int or float, the numeric value of that runtime constant is pushed onto the operand stack as an int or float, respectively.<br>Otherwise, the runtime constant pool entry must be a reference to an instance of class String representing a string literal. A reference to that instance, value, is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The ldc_w instruction is identical to the ldc instruction except for its wider runtime constant pool index.<br>The ldc_w instruction can only be used to push a value of type float taken from the float value set because a constant of type float in the constant pool must be taken from the float value set.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ldc2_w</p>
<p><span class='InstructionTitle'>Opcode</span> : 20(0x14)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Push long or double from runtime constant pool (wide index)</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ldc2_w</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are assembled into an unsigned 16-bit index into the runtime constant pool of the current class, where the value of the index is calculated as (indexbyte1 << 8) | indexbyte2. The index must be a valid index into the runtime constant pool of the current class. The runtime constant pool entry at the index must be a runtime constant of type long or double. The numeric value of that runtime constant is pushed onto the operand stack as a long or double, respectively.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>Only a wide-index version of the ldc2_w instruction exists; there is no ldc2 instruction that pushes a long or double with a single-byte index.<br>The ldc2_w instruction can only be used to push a value of type double taken from the double value set because a constant of type double in the constant pool must be taken from the double value set.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iload</p>
<p><span class='InstructionTitle'>Opcode</span> : 21(0x15)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The local variable at index must contain an int. The value of the local variable at index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iload opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lload</p>
<p><span class='InstructionTitle'>Opcode</span> : 22(0x16)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte. Both index and index + 1 must be indices into the local variable array of the current frame. The local variable at index must contain a long. The value of the local variable at index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lload opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fload</p>
<p><span class='InstructionTitle'>Opcode</span> : 23(0x17)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The local variable at index must contain a float. The value of the local variable at index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fload opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dload</p>
<p><span class='InstructionTitle'>Opcode</span> : 24(0x18)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte. Both index and index + 1 must be indices into the local variable array of the current frame. The local variable at index must contain a double. The value of the local variable at index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dload opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aload</p>
<p><span class='InstructionTitle'>Opcode</span> : 25(0x19)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The local variable at index must contain a reference. The objectref in the local variable at index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The aload instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the astore instruction is intentional.<br>The aload opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iload_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 26(0x1a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iload_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>0 must be an index into the local variable array of the current frame. The local variable at index 0 must contain an int. The value of the local variable at 0 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iload_0 instructions is the same as iload with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iload_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 27(0x1b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iload_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>1 must be an index into the local variable array of the current frame. The local variable at index 1 must contain an int. The value of the local variable at 1 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iload_1 instructions is the same as iload with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iload_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 28(0x1c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iload_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>2 must be an index into the local variable array of the current frame. The local variable at index 2 must contain an int. The value of the local variable at 2 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iload_2 instructions is the same as iload with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iload_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 29(0x1d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iload_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>3 must be an index into the local variable array of the current frame. The local variable at index 3 must contain an int. The value of the local variable at 3 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iload_3 instructions is the same as iload with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lload_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 30(0x1e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lload_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 0 and 1 must be indices into the local variable array of the current frame. The local variable at 0 must contain a long. The value of the local variable at 0 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lload_0 instructions is the same as lload with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lload_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 31(0x1f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lload_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 1 and 2 must be indices into the local variable array of the current frame. The local variable at 1 must contain a long. The value of the local variable at 1 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lload_1 instructions is the same as lload with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lload_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 32(0x20)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lload_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 2 and 3 must be indices into the local variable array of the current frame. The local variable at 2 must contain a long. The value of the local variable at 2 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lload_2 instructions is the same as lload with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lload_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 33(0x21)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lload_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 3 and 4 must be indices into the local variable array of the current frame. The local variable at 3 must contain a long. The value of the local variable at 3 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lload_3 instructions is the same as lload with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fload_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 34(0x22)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fload_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>0 must be an index into the local variable array of the current frame. The local variable at 0 must contain a float. The value of the local variable at 0 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fload_0 instructions is the same as fload with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fload_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 35(0x23)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fload_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>1 must be an index into the local variable array of the current frame. The local variable at 1 must contain a float. The value of the local variable at 1 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fload_1 instructions is the same as fload with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fload_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 36(0x24)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fload_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>2 must be an index into the local variable array of the current frame. The local variable at 2 must contain a float. The value of the local variable at 2 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fload_2 instructions is the same as fload with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fload_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 37(0x25)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fload_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>3 must be an index into the local variable array of the current frame. The local variable at 3 must contain a float. The value of the local variable at 3 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fload_3 instructions is the same as fload with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dload_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 38(0x26)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dload_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 0 and 1 must be indices into the local variable array of the current frame. The local variable at 0 must contain a double. The value of the local variable at 0 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dload_0 instructions is the same as dload with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dload_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 39(0x27)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dload_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 1 and 2 must be indices into the local variable array of the current frame. The local variable at 1 must contain a double. The value of the local variable at 1 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dload_1 instructions is the same as dload with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dload_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 40(0x28)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dload_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 2 and 3 must be indices into the local variable array of the current frame. The local variable at 2 must contain a double. The value of the local variable at 2 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dload_2 instructions is the same as dload with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dload_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 41(0x29)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dload_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 3 and 4 must be indices into the local variable array of the current frame. The local variable at 3 must contain a double. The value of the local variable at 3 is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dload_3 instructions is the same as dload with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aload_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 42(0x2a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aload_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Load the item in the local variable array of the current frame with index 0. The local variable at that index must contain a reference. The objectref in the local variable at that index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>An aload_0 instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_0 instruction is intentional. The aload_0 instructions is the same as aload with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aload_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 43(0x2b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aload_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Load the item in the local variable array of the current frame with index 1. The local variable at that index must contain a reference. The objectref in the local variable at that index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>An aload_1 instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_1 instruction is intentional. The aload_1 instructions is the same as aload with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aload_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 44(0x2c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aload_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Load the item in the local variable array of the current frame with index 2. The local variable at that index must contain a reference. The objectref in the local variable at that index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>An aload_2 instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_2 instruction is intentional. The aload_2 instructions is the same as aload with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aload_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 45(0x2d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aload_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Load the item in the local variable array of the current frame with index 3. The local variable at that index must contain a reference. The objectref in the local variable at that index is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>An aload_3 instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_3 instruction is intentional. The aload_3 instructions is the same as aload with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iaload</p>
<p><span class='InstructionTitle'>Opcode</span> : 46(0x2e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load int from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iaload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type int. The index must be of type int. Both arrayref and index are popped from the operand stack. The int value in the component of the array at index is retrieved and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, iaload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the iaload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : laload</p>
<p><span class='InstructionTitle'>Opcode</span> : 47(0x2f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load long from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>laload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type long. The index must be of type int. Both arrayref and index are popped from the operand stack. The long value in the component of the array at index is retrieved and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, laload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the laload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : faload</p>
<p><span class='InstructionTitle'>Opcode</span> : 48(0x30)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load float from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>faload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type float. The index must be of type int. Both arrayref and index are popped from the operand stack. The float value in the component of the array at index is retrieved and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, faload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the faload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : daload</p>
<p><span class='InstructionTitle'>Opcode</span> : 49(0x31)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load double from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>daload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type double. The index must be of type int. Both arrayref and index are popped from the operand stack. The double value in the component of the array at index is retrieved and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, daload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the daload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aaload</p>
<p><span class='InstructionTitle'>Opcode</span> : 50(0x32)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load reference from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aaload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be<br>of type reference and must refer to an array whose components are of type reference. The index must be of type int. Both arrayref and index are popped from the operand stack. The reference value in the component of the array at index is retrieved and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, aaload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the aaload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : baload</p>
<p><span class='InstructionTitle'>Opcode</span> : 51(0x33)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load byte or boolean from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>baload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index must be of type int. Both arrayref and index are popped from the operand stack. If the components of the array are of type byte, the component of the array at index is retrieved and sign-extended to an int value. If the components of the array are of type boolean, the component of the array at index is retrieved and zero-extended to an int value. In either case the resulting value is pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, baload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the baload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : caload</p>
<p><span class='InstructionTitle'>Opcode</span> : 52(0x34)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load char from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>caload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type char. The index must be of type int. Both arrayref and index are popped from the operand stack. The component of the array at index is retrieved and zero-extended to an int value. That value is pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, caload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the caload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : saload</p>
<p><span class='InstructionTitle'>Opcode</span> : 53(0x35)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Load short from array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>saload</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type short. The index must be of type int. Both arrayref and index are popped from the operand stack. The component of the array at index is retrieved and sign-extended to an int value. That value is pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, saload throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the saload instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : istore</p>
<p><span class='InstructionTitle'>Opcode</span> : 54(0x36)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store int into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>istore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at index is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The istore opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lstore</p>
<p><span class='InstructionTitle'>Opcode</span> : 55(0x37)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store long into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lstore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte. Both index and index + 1 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type long. It is popped from the operand stack, and the local variables at index and index + 1 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lstore opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fstore</p>
<p><span class='InstructionTitle'>Opcode</span> : 56(0x38)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store float into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fstore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting in value. The value of the local variable at index is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fstore opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dstore</p>
<p><span class='InstructionTitle'>Opcode</span> : 57(0x39)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store double into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dstore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte. Both index and index + 1 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in value. The local variables at index and index + 1 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dstore opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : astore</p>
<p><span class='InstructionTitle'>Opcode</span> : 58(0x3a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store reference into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>astore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at index is set to objectref.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The astore instruction is used with an objectref of type returnAddress when implementing the finally clauses of the Java programming language. The aload instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the astore instruction is intentional.<br>The astore opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : istore_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 59(0x3b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store int into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>istore_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>0 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at 0 is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The istore_0 instructions is the same as istore with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : istore_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 60(0x3c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store int into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>istore_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>1 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at 1 is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The istore_1 instructions is the same as istore with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : istore_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 61(0x3d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store int into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>istore_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>2 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at 2 is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The istore_2 instructions is the same as istore with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : istore_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 62(0x3e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store int into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>istore_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>3 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at 3 is set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The istore_3 instructions is the same as istore with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lstore_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 63(0x3f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store long into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lstore_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 0 and 1 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type long. It is popped from the operand stack, and the local variables at 0 and 1 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lstore_0 instructions is the same as lstore with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lstore_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 64(0x40)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store long into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lstore_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 1 and 2 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type long. It is popped from the operand stack, and the local variables at 1 and 2 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lstore_1 instructions is the same as lstore with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lstore_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 65(0x41)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store long into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lstore_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 2 and 3 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type long. It is popped from the operand stack, and the local variables at 2 and 3 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lstore_2 instructions is the same as lstore with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lstore_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 66(0x42)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store long into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lstore_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 3 and 4 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type long. It is popped from the operand stack, and the local variables at 3 and 4 are set to value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The lstore_3 instructions is the same as lstore with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fstore_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 67(0x43)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store float into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fstore_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>0 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting  value1. The value of the local variable at 0 is set to value1.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fstore_0 is the same as fstore with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fstore_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 68(0x44)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store float into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fstore_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>1 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting  value1. The value of the local variable at 1 is set to value1.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fstore_1 is the same as fstore with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fstore_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 69(0x45)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store float into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fstore_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>2 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting  value1. The value of the local variable at 2 is set to value1.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fstore_2 is the same as fstore with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fstore_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 70(0x46)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store float into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fstore_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>3 must be an index into the local variable array of the current frame. The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting  value1. The value of the local variable at 3 is set to value1.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fstore_3 is the same as fstore with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dstore_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 71(0x47)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store double into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dstore_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 0 and 1 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in value1. The local variables at 0 and 1 are set to value1.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dstore_0 instructions is the same as dstore with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dstore_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 72(0x48)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store double into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dstore_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 1 and 2 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in new value. The local variables at 1 and 2 are set to new value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dstore_1 instructions is the same as dstore with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dstore_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 73(0x49)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store double into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dstore_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 2 and 3 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in new value. The local variables at 2 and 3 are set to new value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dstore_2 instructions is the same as dstore with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dstore_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 74(0x4a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store double into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dstore_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both 3 and 4 must be indices into the local variable array of the current frame. The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in new value. The local variables at 3 and 4 are set to new value.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dstore_3 instructions is the same as dstore with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : astore_0</p>
<p><span class='InstructionTitle'>Opcode</span> : 75(0x4b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store reference into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>astore_0</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>0 is the index into the local variable array of the current frame. The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at index 0 is set to objectref.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The astore_<n> instruction is used with an objectref of type returnAddress when implementing the finally clauses of the Java programming language. An aload_<n> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_<n> instruction is intentional.<br>The astore_0 instructions is the same as astore with an index of 0, except that the operand 0 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : astore_1</p>
<p><span class='InstructionTitle'>Opcode</span> : 76(0x4c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store reference into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>astore_1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>1 is the index into the local variable array of the current frame. The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at index 1 is set to objectref.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The astore_<n> instruction is used with an objectref of type returnAddress when implementing the finally clauses of the Java programming language. An aload_<n> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_<n> instruction is intentional.<br>The astore_1 instructions is the same as astore with an index of 1, except that the operand 1 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : astore_2</p>
<p><span class='InstructionTitle'>Opcode</span> : 77(0x4d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store reference into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>astore_2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>2 is the index into the local variable array of the current frame. The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at index 2 is set to objectref.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The astore_<n> instruction is used with an objectref of type returnAddress when implementing the finally clauses of the Java programming language. An aload_<n> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_<n> instruction is intentional.<br>The astore_2 instructions is the same as astore with an index of 2, except that the operand 2 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : astore_3</p>
<p><span class='InstructionTitle'>Opcode</span> : 78(0x4e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store reference into local variable</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>astore_3</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>3 is the index into the local variable array of the current frame. The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at index 3 is set to objectref.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The astore_<n> instruction is used with an objectref of type returnAddress when implementing the finally clauses of the Java programming language. An aload_<n> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_<n> instruction is intentional.<br>The astore_3 instructions is the same as astore with an index of 3, except that the operand 3 is implicit.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 79(0x4f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into int array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type int. Both index and value must be of type int. The arrayref, index, and value are popped from the operand stack. The int value is stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, iastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the iastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 80(0x50)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into long array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type long. The index must be of type int, and value must be of type long. The arrayref, index, and value are popped from the operand stack. The long value is stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, lastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the lastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 81(0x51)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into float array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type float. The index must be of type int, and the value must be of type float. The arrayref, index, and value are popped from the operand stack. The float value undergoes value set conversion, resulting in value, and value is stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, fastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the fastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 82(0x52)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into double array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type double. The index must be of type int, and value must be of type double. The arrayref, index, and value are popped from the operand stack. The double value undergoes value set conversion, resulting in value, which is stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, dastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the dastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : aastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 83(0x53)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into reference array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>aastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type reference. The index must be of type int and value must be of type reference. The arrayref, index, and value are popped from the operand stack. The reference value is stored as the component of the array at index.<br>The type of value must be assignment compatible with the type of the components of the array referenced by arrayref. Assignment of a value of reference type S (source) to a variable of reference type T (target) is allowed only when the type S supports all the operations defined on type T. The detailed rules follow:<br>If S is a class type, then:<br>If T is a class type, then S must be the same class as T, or S must be a subclass of T;<br>If T is an interface type, S must implement interface T.<br>If S is an interface type, then:<br>If T is a class type, then T must be Object.<br>If T is an interface type, then T must be the same interface as S or a superinterface of S.<br>If S is an array type, namely, the type SC[], that is, an array of components of type SC, then:<br>If T is a class type, then T must be Object.<br>If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:<br>TC and SC are the same primitive type.<br>TC and SC are reference types, and type SC is assignable to TC by these runtime rules.<br>If T is an interface type, T must be one of the interfaces implemented by arrays.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, aastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the aastore instruction throws an ArrayIndexOutOfBoundsException.<br>Otherwise, if arrayref is not null and the actual type of value is not assignment compatible with the actual type of the components of the array, aastore throws an ArrayStoreException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : bastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 84(0x54)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into byte or boolean array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>bastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index and the value must both be of type int. The arrayref, index, and value are popped from the operand stack. If the components of the array are of type byte, the int value is truncated to a byte and stored as the component of the array indexed by index. If the components of the array are of type boolean, the int value is truncated to its low order bit then zero-extended to the storage size for components of boolean arrays used by the implementation. The result is stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, bastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the bastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : castore</p>
<p><span class='InstructionTitle'>Opcode</span> : 85(0x55)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into char array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>castore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type char. The index and the value must both be of type int. The arrayref, index, and value are popped from the operand stack. The int value is truncated to a char and stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, castore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the castore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : sastore</p>
<p><span class='InstructionTitle'>Opcode</span> : 86(0x56)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Store into short array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>sastore</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., array, index, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array whose components are of type short. Both index and value must be of type int. The arrayref, index, and value are popped from the operand stack. The int value is truncated to a short and stored as the component of the array indexed by index.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If arrayref is null, sastore throws a NullPointerException.<br>Otherwise, if index is not within the bounds of the array referenced by arrayref, the sastore instruction throws an ArrayIndexOutOfBoundsException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : pop</p>
<p><span class='InstructionTitle'>Opcode</span> : 87(0x57)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Pop the top operand stack value</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>pop</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Pop the top value from the operand stack.<br>The pop instruction must not be used unless value is a value of a category 1 computational type.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : pop2</p>
<p><span class='InstructionTitle'>Opcode</span> : 88(0x58)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Pop the top one or two operand stack values</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>pop2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Form 1:
..., value2, value1  ...
where each of value1 and value2 is a value of a category 1 computational type.
Form 2:
..., value  ...
where value is a value of a category 2 computational type.</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Pop the top one or two values from the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup</p>
<p><span class='InstructionTitle'>Opcode</span> : 89(0x59)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top operand stack value</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., value, value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top value on the operand stack and push the duplicated value onto the operand stack.<br>The dup instruction must not be used unless value is a value of a category 1 computational type.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup_x1</p>
<p><span class='InstructionTitle'>Opcode</span> : 90(0x5a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top operand stack value and insert two values down</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup_x1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value2, value1  ..., value1, value2, value1</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top value on the operand stack and insert the duplicated value two values down in the operand stack.<br>The dup_x1 instruction must not be used unless both value1 and value2 are values of a category 1 computational type.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup_x2</p>
<p><span class='InstructionTitle'>Opcode</span> : 91(0x5b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top operand stack value and insert two or three values down</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup_x2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Form 1:
..., value3, value2, value1  ..., value1, value3, value2, value1
where value1, value2, and value3 are all values of a category 1 computational type.
Form 2:
..., value2, value1  ..., value1, value2, value1
where value1 is a value of a category 1 computational type and value2 is a value of a category 2 computational type.</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top value on the operand stack and insert the duplicated value two or three values down in the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup2</p>
<p><span class='InstructionTitle'>Opcode</span> : 92(0x5c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top one or two operand stack values</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Form 1:
..., value2, value1  ..., value2, value1, value2, value1
where both value1 and value2 are values of a category 1 computational type.
Form 2:
..., value  ..., value, value
where value is a value of a category 2 computational type.</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top one or two values on the operand stack and push the duplicated value or values back onto the operand stack in the original order.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup2_x1</p>
<p><span class='InstructionTitle'>Opcode</span> : 93(0x5d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top one or two operand stack values and insert two or three values down</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup2_x1</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Form 1:
..., value3, value2, value1  ..., value2, value1, value3, value2, value1
where value1, value2, and value3 are all values of a category 1 computational type.
Form 2:
..., value2, value1  ..., value1, value2, value1
where value1 is a value of a category 2 computational type and value2 is a value of a category 1 computational type.</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, one value beneath the original value or values in the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dup2_x2</p>
<p><span class='InstructionTitle'>Opcode</span> : 94(0x5e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Duplicate the top one or two operand stack values and insert two, three, or four values down</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dup2_x2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Form 1:
..., value4, value3, value2, value1  ..., value2, value1, value4, value3, value2, value1
where value1, value2, value3, and value4 are all values of a category 1 computational type.
Form 2:
..., value3, value2, value1  ..., value1, value3, value2, value1
where value1 is a value of a category 2 computational type and value2 and value3 are both values of a category 1 computational type.
Form 3:
..., value3, value2, value1  ..., value2, value1, value3, value2, value1
where value1 and value2 are both values of a category 1 computational type and value3 is a value of a category 2 computational type.
Form 4:
..., value2, value1  ..., value1, value2, value1
where value1 and value2 are both values of a category 2 computational type.</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Duplicate the top one or two values on the operand stack and insert the duplicated values, in the original order, into the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : swap</p>
<p><span class='InstructionTitle'>Opcode</span> : 95(0x5f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Swap the top two operand stack values</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>swap</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value2, value1  ..., value1, value2</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Swap the top two values on the operand stack.<br>The swap instruction must not be used unless value1 and value2 are both values of a category 1 computational type.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The Java virtual machine does not provide an instruction implementing a swap on operands of category 2 computational types.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iadd</p>
<p><span class='InstructionTitle'>Opcode</span> : 96(0x60)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Add int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iadd</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 + value2. The result is pushed onto the operand stack.<br>The result is the 32 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type int. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an iadd instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ladd</p>
<p><span class='InstructionTitle'>Opcode</span> : 97(0x61)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Add long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ladd</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. The values are popped from the operand stack. The long result is value1 + value2. The result is pushed onto the operand stack.<br>The result is the 64 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type long. If overflow occurs, the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an ladd instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fadd</p>
<p><span class='InstructionTitle'>Opcode</span> : 98(0x62)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Add float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fadd</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The float result is value1 + value2. The result is pushed onto the operand stack.<br>The result of an fadd instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>The sum of two infinities of opposite sign is NaN.<br>The sum of two infinities of the same sign is the infinity of that sign.<br>The sum of an infinity and any finite value is equal to the infinity.<br>The sum of two zeroes of opposite sign is positive zero.<br>The sum of two zeroes of the same sign is the zero of that sign.<br>The sum of a zero and a nonzero finite value is equal to the nonzero value.<br>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a float, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an fadd instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dadd</p>
<p><span class='InstructionTitle'>Opcode</span> : 99(0x63)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Add double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dadd</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The double result is value1 + value2. The result is pushed onto the operand stack.<br>The result of a dadd instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>The sum of two infinities of opposite sign is NaN.<br>The sum of two infinities of the same sign is the infinity of that sign.<br>The sum of an infinity and any finite value is equal to the infinity.<br>The sum of two zeroes of opposite sign is positive zero.<br>The sum of two zeroes of the same sign is the zero of that sign.<br>The sum of a zero and a nonzero finite value is equal to the nonzero value.<br>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a double, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a dadd instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : isub</p>
<p><span class='InstructionTitle'>Opcode</span> : 100(0x64)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Subtract int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>isub</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 - value2. The result is pushed onto the operand stack.<br>For int subtraction, a - b produces the same result as a + (-b). For int values, subtraction from zero is the same as negation.<br>The result is the 32 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type int. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an isub instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lsub</p>
<p><span class='InstructionTitle'>Opcode</span> : 101(0x65)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Subtract long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lsub</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. The values are popped from the operand stack. The long result is value1 - value2. The result is pushed onto the operand stack.<br>For long subtraction, a-b produces the same result as a+(-b). For long values, subtraction from zero is the same as negation.<br>The result is the 64 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type long. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an lsub instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fsub</p>
<p><span class='InstructionTitle'>Opcode</span> : 102(0x66)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Subtract float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fsub</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The float result is value1 - value2. The result is pushed onto the operand stack.<br>For float subtraction, it is always the case that a-b produces the same result as a+(-b). However, for the fsub instruction, subtraction from zero is not the same as negation, because if x is +0.0, then 0.0-x equals +0.0, but -x equals -0.0.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an fsub instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dsub</p>
<p><span class='InstructionTitle'>Opcode</span> : 103(0x67)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Subtract double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dsub</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The double result is value1 - value2. The result is pushed onto the operand stack.<br>For double subtraction, it is always the case that a-b produces the same result as a+(-b). However, for the dsub instruction, subtraction from zero is not the same as negation, because if x is +0.0, then 0.0-x equals +0.0, but -x equals -0.0.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a dsub instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : imul</p>
<p><span class='InstructionTitle'>Opcode</span> : 104(0x68)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Multiply int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>imul</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 * value2. The result is pushed onto the operand stack.<br>The result is the 32 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type int. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an imul instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lmul</p>
<p><span class='InstructionTitle'>Opcode</span> : 105(0x69)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Multiply long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lmul</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. The values are popped from the operand stack. The long result is value1 * value2. The result is pushed onto the operand stack.<br>The result is the 64 low-order bits of the true mathematical result in a sufficiently wide twos-complement format, represented as a value of type long. If overflow occurs, the sign of the result may not be the same as the sign of the mathematical sum of the two values.<br>Despite the fact that overflow may occur, execution of an lmul instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fmul</p>
<p><span class='InstructionTitle'>Opcode</span> : 106(0x6a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Multiply float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fmul</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The float result is value1 * value2. The result is pushed onto the operand stack.<br>The result of an fmul instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result is positive if both values have the same sign, and negative if the values have different signs.<br>Multiplication of an infinity by a zero results in NaN.<br>Multiplication of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.<br>In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a float, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an fmul instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dmul</p>
<p><span class='InstructionTitle'>Opcode</span> : 107(0x6b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Multiply double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dmul</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The double result is value1 * value2. The result is pushed onto the operand stack.<br>The result of a dmul instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result is positive if both values have the same sign and negative if the values have different signs.<br>Multiplication of an infinity by a zero results in NaN.<br>Multiplication of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.<br>In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a double, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of a dmul instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : idiv</p>
<p><span class='InstructionTitle'>Opcode</span> : 108(0x6c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Divide int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>idiv</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is the value of the Java programming language expression value1 / value2. The result is pushed onto the operand stack.<br>An int division rounds towards 0; that is, the quotient produced for int values in n/d is an int value q whose magnitude is as large as possible while satisfying . Moreover, q is positive when  and n and d have the same sign, but q is negative when  and n and d have opposite signs.<br>There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the int type, and the divisor is -1, then overflow occurs, and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the value of the divisor in an int division is 0, idiv throws an ArithmeticException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ldiv</p>
<p><span class='InstructionTitle'>Opcode</span> : 109(0x6d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Divide long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ldiv</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. The values are popped from the operand stack. The long result is the value of the Java programming language expression value1 / value2. The result is pushed onto the operand stack.<br>A long division rounds towards 0; that is, the quotient produced for long values in n / d is a long value q whose magnitude is as large as possible while satisfying . Moreover, q is positive when  and n and d have the same sign, but q is negative when  and n and d have opposite signs.<br>There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the long type and the divisor is -1, then overflow occurs and the result is equal to the dividend; despite the overflow, no exception is thrown in this case.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the value of the divisor in a long division is 0, ldiv throws an ArithmeticException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fdiv</p>
<p><span class='InstructionTitle'>Opcode</span> : 110(0x6e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Divide float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fdiv</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The float result is value1 / value2. The result is pushed onto the operand stack.<br>The result of an fdiv instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result is positive if both values have the same sign, negative if the values have different signs.<br>Division of an infinity by an infinity results in NaN.<br>Division of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.<br>Division of a finite value by an infinity results in a signed zero, with the sign-producing rule just given.<br>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero, with the sign-producing rule just given.<br>Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest float using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a float, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a float, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of an fdiv instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ddiv</p>
<p><span class='InstructionTitle'>Opcode</span> : 111(0x6f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Divide double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ddiv</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The double result is value1 / value2. The result is pushed onto the operand stack.<br>The result of a ddiv instruction is governed by the rules of IEEE arithmetic:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result is positive if both values have the same sign, negative if the values have different signs.<br>Division of an infinity by an infinity results in NaN.<br>Division of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.<br>Division of a finite value by an infinity results in a signed zero, with the sign-producing rule just given.<br>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero, with the sign-producing rule just given.<br>Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN, the quotient is computed and rounded to the nearest double using IEEE 754 round to nearest mode. If the magnitude is too large to represent as a double, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a double, we say the operation underflows; the result is then a zero of appropriate sign.<br>The Java virtual machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of a ddiv instruction never throws a runtime exception.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : irem</p>
<p><span class='InstructionTitle'>Opcode</span> : 112(0x70)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Remainder int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>irem</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 - (value1 / value2) * value2. The result is pushed onto the operand stack.<br>The result of the irem instruction is such that (a/b)*b + (a%b) is equal to a. This identity holds even in the special case in which the dividend is the negative int of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the value of the divisor for an int remainder operator is 0, irem throws an ArithmeticException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lrem</p>
<p><span class='InstructionTitle'>Opcode</span> : 113(0x71)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Remainder long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lrem</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. The values are popped from the operand stack. The long result is value1 - (value1 / value2) * value2. The result is pushed onto the operand stack.<br>The result of the lrem instruction is such that (a/b)*b + (a%b) is equal to a. This identity holds even in the special case in which the dividend is the negative long of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the value of the divisor for a long remainder operator is 0, lrem throws an ArithmeticException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : frem</p>
<p><span class='InstructionTitle'>Opcode</span> : 114(0x72)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Remainder float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>frem</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The result is calculated and pushed onto the operand stack as a float.<br>The result of an frem instruction is not the same as that of the so-called remainder operation defined by IEEE 754. The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator. Instead, the Java virtual machine defines frem to behave in a manner analogous to that of the Java virtual machine integer remainder instructions (irem and lrem); this may be compared with the C library function fmod.<br>The result of an frem instruction is governed by these rules:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result equals the sign of the dividend.<br>If the dividend is an infinity or the divisor is a zero or both, the result is NaN.<br>If the dividend is finite and the divisor is an infinity, the result equals the dividend.<br>If the dividend is a zero and the divisor is finite, the result equals the dividend.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN, the floating-point remainder result from a dividend value1 and a divisor value2 is defined by the mathematical relation result = value1 - (value2 * q), where q is an integer that is negative only if value1 / value2 is negative and positive only if value1 / value2 is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of value1 and value2.<br>Despite the fact that division by zero may occur, evaluation of an frem instruction never throws a runtime exception. Overflow, underflow, or loss of precision cannot occur.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : drem</p>
<p><span class='InstructionTitle'>Opcode</span> : 115(0x73)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Remainder double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>drem</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. The result is calculated and pushed onto the operand stack as a double.<br>The result of a drem instruction is not the same as that of the so-called remainder operation defined by IEEE 754. The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator. Instead, the Java virtual machine defines drem to behave in a manner analogous to that of the Java virtual machine integer remainder instructions (irem and lrem); this may be compared with the C library function fmod.<br>The result of a drem instruction is governed by these rules:<br>If either value1 or value2 is NaN, the result is NaN.<br>If neither value1 nor value2 is NaN, the sign of the result equals the sign of the dividend.<br>If the dividend is an infinity or the divisor is a zero or both, the result is NaN.<br>If the dividend is finite and the divisor is an infinity, the result equals the dividend.<br>If the dividend is a zero and the divisor is finite, the result equals the dividend.<br>In the remaining cases, where neither operand is an infinity, a zero, or NaN, the floating-point remainder result from a dividend value1 and a divisor value2 is defined by the mathematical relation result = value1 - (value2 * q), where q is an integer that is negative only if value1 / value2 is negative, and positive only if value1 / value2 is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of value1 and value2.<br>Despite the fact that division by zero may occur, evaluation of a drem instruction never throws a runtime exception. Overflow, underflow, or loss of precision cannot occur.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The IEEE 754 remainder operation may be computed by the library routine Math.IEEEremainder.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ineg</p>
<p><span class='InstructionTitle'>Opcode</span> : 116(0x74)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Negate int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ineg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack. The int result is the arithmetic negation of value, -value. The result is pushed onto the operand stack.<br>For int values, negation is the same as subtraction from zero. Because the Java virtual machine uses twos-complement representation for integers and the range of twos-complement values is not symmetric, the negation of the maximum negative int results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.<br>For all int values x, -x equals (~x) + 1.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lneg</p>
<p><span class='InstructionTitle'>Opcode</span> : 117(0x75)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Negate long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lneg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type long. It is popped from the operand stack. The long result is the arithmetic negation of value, -value. The result is pushed onto the operand stack.<br>For long values, negation is the same as subtraction from zero. Because the Java virtual machine uses twos-complement representation for integers and the range of twos-complement values is not symmetric, the negation of the maximum negative long results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.<br>For all long values x, -x equals (~x) + 1.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fneg</p>
<p><span class='InstructionTitle'>Opcode</span> : 118(0x76)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Negate float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fneg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting in value. The float result is the arithmetic negation of value. This result is pushed onto the operand stack.<br>For float values, negation is not the same as subtraction from zero. If x is +0.0, then 0.0-x equals +0.0, but -x equals -0.0. Unary minus merely inverts the sign of a float.<br>Special cases of interest:<br>If the operand is NaN, the result is NaN (recall that NaN has no sign).<br>If the operand is an infinity, the result is the infinity of opposite sign.<br>If the operand is a zero, the result is the zero of opposite sign.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dneg</p>
<p><span class='InstructionTitle'>Opcode</span> : 119(0x77)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Negate double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dneg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type double. It is popped from the operand stack and undergoes value set conversion, resulting in value. The double result is the arithmetic negation of value. The result is pushed onto the operand stack.<br>For double values, negation is not the same as subtraction from zero. If x is +0.0, then 0.0-x equals +0.0, but -x equals -0.0. Unary minus merely inverts the sign of a double.<br>Special cases of interest:<br>If the operand is NaN, the result is NaN (recall that NaN has no sign).<br>If the operand is an infinity, the result is the infinity of opposite sign.<br>If the operand is a zero, the result is the zero of opposite sign.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ishl</p>
<p><span class='InstructionTitle'>Opcode</span> : 120(0x78)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Shift left int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ishl</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting value1 left by s bit positions, where s is the value of the low 5 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This is equivalent (even if overflow occurs) to multiplication by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lshl</p>
<p><span class='InstructionTitle'>Opcode</span> : 121(0x79)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Shift left</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lshl</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value1 must be of type long, and value2 must be of type int. The values are popped from the operand stack. A long result is calculated by shifting value1 left by s bit positions, where s is the low 6 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>This is equivalent (even if overflow occurs) to multiplication by 2 to the power s. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x3f.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ishr</p>
<p><span class='InstructionTitle'>Opcode</span> : 122(0x7a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Arithmetic shift right int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ishr</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting value1 right by s bit positions, with sign extension, where s is the value of the low 5 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The resulting value is , where s is value2 & 0x1f. For nonnegative value1, this is equivalent to truncating int division by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lshr</p>
<p><span class='InstructionTitle'>Opcode</span> : 123(0x7b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Arithmetic shift right long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lshr</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value1 must be of type long, and value2 must be of type int. The values are popped from the operand stack. A long result is calculated by shifting value1 right by s bit positions, with sign extension, where s is the value of the low 6 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The resulting value is  , where s is value2 & 0x3f. For nonnegative value1, this is equivalent to truncating long division by 2 to the power s. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x3f.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iushr</p>
<p><span class='InstructionTitle'>Opcode</span> : 124(0x7c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Logical shift right int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iushr</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting value1 right by s bit positions, with zero extension, where s is the value of the low 5 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>If value1 is positive and s is value2 & 0x1f, the result is the same as that of value1 >> s; if value1 is negative, the result is equal to the value of the expression (value1 >> s) + (2 << ~s). The addition of the (2 << ~s) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 31, inclusive.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lushr</p>
<p><span class='InstructionTitle'>Opcode</span> : 125(0x7d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Logical shift right long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lushr</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value1 must be of type long, and value2 must be of type int. The values are popped from the operand stack. A long result is calculated by shifting value1 right logically (with zero extension) by the amount indicated by the low 6 bits of value2. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>If value1 is positive and s is value2 & 0x3f, the result is the same as that of value1 >> s; if value1 is negative, the result is equal to the value of the expression (value1 >> s) + (2L << ~s). The addition of the (2L << ~s) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 63, inclusive.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iand</p>
<p><span class='InstructionTitle'>Opcode</span> : 126(0x7e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean AND int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iand</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are popped from the operand stack. An int result is calculated by taking the bitwise AND (conjunction) of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : land</p>
<p><span class='InstructionTitle'>Opcode</span> : 127(0x7f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean AND long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>land</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. They are popped from the operand stack. A long result is calculated by taking the bitwise AND of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ior</p>
<p><span class='InstructionTitle'>Opcode</span> : 128(0x80)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean OR int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ior</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are popped from the operand stack. An int result is calculated by taking the bitwise inclusive OR of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lor</p>
<p><span class='InstructionTitle'>Opcode</span> : 129(0x81)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean OR long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lor</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. They are popped from the operand stack. A long result is calculated by taking the bitwise inclusive OR of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ixor</p>
<p><span class='InstructionTitle'>Opcode</span> : 130(0x82)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean XOR int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ixor</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are popped from the operand stack. An int result is calculated by taking the bitwise exclusive OR of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lxor</p>
<p><span class='InstructionTitle'>Opcode</span> : 131(0x83)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Boolean XOR long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lxor</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. They are popped from the operand stack. A long result is calculated by taking the bitwise exclusive OR of value1 and value2. The result is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iinc</p>
<p><span class='InstructionTitle'>Opcode</span> : 132(0x84)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Increment local variable by constant</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iinc</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>No change</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte that must be an index into the local variable array of the current frame. The const is an immediate signed byte. The local variable at index must contain an int. The value const is first sign-extended to an int, and then the local variable at index is incremented by that amount.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The iinc opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index and to increment it by a two-byte immediate value.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2l</p>
<p><span class='InstructionTitle'>Opcode</span> : 133(0x85)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2l</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack and sign-extended to a long result. That result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2l instruction performs a widening primitive conversion. Because all values of type int are exactly representable by type long, the conversion is exact.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2f</p>
<p><span class='InstructionTitle'>Opcode</span> : 134(0x86)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2f</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack and converted to the float result using IEEE 754 round to nearest mode. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2f instruction performs a widening primitive conversion, but may result in a loss of precision because values of type float have only 24 significand bits.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2d</p>
<p><span class='InstructionTitle'>Opcode</span> : 135(0x87)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2d</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack and converted to a double result. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2d instruction performs a widening primitive conversion. Because all values of type int are exactly representable by type double, the conversion is exact.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : l2i</p>
<p><span class='InstructionTitle'>Opcode</span> : 136(0x88)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert long to int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>l2i</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type long. It is popped from the operand stack and converted to an int result by taking the low-order 32 bits of the long value and discarding the high-order 32 bits. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The l2i instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : l2f</p>
<p><span class='InstructionTitle'>Opcode</span> : 137(0x89)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert long to float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>l2f</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type long. It is popped from the operand stack and converted to a float result using IEEE 754 round to nearest mode. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The l2f instruction performs a widening primitive conversion that may lose precision because values of type float have only 24 significand bits.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : l2d</p>
<p><span class='InstructionTitle'>Opcode</span> : 138(0x8a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert long to double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>l2d</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type long. It is popped from the operand stack and converted to a double result using IEEE 754 round to nearest mode. The result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The l2d instruction performs a widening primitive conversion that may lose precision because values of type double have only 53 significand bits.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : f2i</p>
<p><span class='InstructionTitle'>Opcode</span> : 139(0x8b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert float to int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>f2i</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting in value. Then value is converted to an int result. This result is pushed onto the operand stack:<br>If the value is NaN, the result of the conversion is an int 0.<br>Otherwise, if the value is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an int, then the result is the int value V.<br>Otherwise, either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The f2i instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value and may also lose precision.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : f2l</p>
<p><span class='InstructionTitle'>Opcode</span> : 140(0x8c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert float to long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>f2l</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting in value. Then value is converted to a long result. This result is pushed onto the operand stack:<br>If the value is NaN, the result of the conversion is a long 0.<br>Otherwise, if the value is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a long, then the result is the long value V.<br>Otherwise, either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The f2l instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value and may also lose precision.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : f2d</p>
<p><span class='InstructionTitle'>Opcode</span> : 141(0x8d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert float to double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>f2d</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type float. It is popped from the operand stack and undergoes value set conversion, resulting in value. Then value is converted to a double result. This result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>Where an f2d instruction is FP-strict it performs a widening primitive conversion. Because all values of the float value set are exactly representable by values of the double value set, such a conversion is exact.<br>Where an f2d instruction is not FP-strict, the result of the conversion may be taken from the double-extended-exponent value set; it is not necessarily rounded to the nearest representable value in the double value set. However, if the operand value is taken from the float-extended-exponent value set and the target result is constrained to the double value set, rounding of value may be required.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : d2i</p>
<p><span class='InstructionTitle'>Opcode</span> : 142(0x8e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert double to int</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>d2i</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion resulting in value. Then value is converted to an int. The result is pushed onto the operand stack:<br>If the value is NaN, the result of the conversion is an int 0.<br>Otherwise, if the value is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as an int, then the result is the int value V.<br>Otherwise, either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type int, or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type int.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The d2i instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value and may also lose precision.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : d2l</p>
<p><span class='InstructionTitle'>Opcode</span> : 143(0x8f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert double to long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>d2l</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>

<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion resulting in value. Then value is converted to a long. The result is pushed onto the operand stack:<br>If the value is NaN, the result of the conversion is a long 0.<br>Otherwise, if the value is not an infinity, it is rounded to an integer value V, rounding towards zero using IEEE 754 round towards zero mode. If this integer value V can be represented as a long, then the result is the long value V.<br>Otherwise, either the value must be too small (a negative value of large magnitude or negative infinity), and the result is the smallest representable value of type long, or the value must be too large (a positive value of large magnitude or positive infinity), and the result is the largest representable value of type long.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The d2l instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value and may also lose precision.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : d2f</p>
<p><span class='InstructionTitle'>Opcode</span> : 144(0x90)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert double to float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>d2f</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type double. It is popped from the operand stack and undergoes value set conversion resulting in value. Then value is converted to a float result using IEEE 754 round to nearest mode. The result is pushed onto the operand stack.<br>Where an d2f instruction is FP-strict, the result of the conversion is always rounded to the nearest representable value in the float value set.<br>Where an d2f instruction is not FP-strict, the result of the conversion may be taken from the float-extended-exponent value set; it is not necessarily rounded to the nearest representable value in the float value set.<br>A finite value too small to be represented as a float is converted to a zero of the same sign; a finite value too large to be represented as a float is converted to an infinity of the same sign. A double NaN is converted to a float NaN.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The d2f instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value and may also lose precision.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2b</p>
<p><span class='InstructionTitle'>Opcode</span> : 145(0x91)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to byte</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2b</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack, truncated to a byte, then sign-extended to an int result. That result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2b instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2c</p>
<p><span class='InstructionTitle'>Opcode</span> : 146(0x92)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to char</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2c</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack, truncated to char, then zero-extended to an int result. That result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2c instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result (which is always positive) may also not have the same sign as value.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : i2s</p>
<p><span class='InstructionTitle'>Opcode</span> : 147(0x93)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Convert int to short</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>i2s</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value on the top of the operand stack must be of type int. It is popped from the operand stack, truncated to a short, then sign-extended to an int result. That result is pushed onto the operand stack.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The i2s instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lcmp</p>
<p><span class='InstructionTitle'>Opcode</span> : 148(0x94)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Compare long</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lcmp</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type long. They are both popped from the operand stack, and a signed integer comparison is performed. If value1 is greater than value2, the int value 1 is pushed onto the operand stack. If value1 is equal to value2, the int value 0 is pushed onto the operand stack. If value1 is less than value2, the int value -1 is pushed onto the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fcmpl</p>
<p><span class='InstructionTitle'>Opcode</span> : 149(0x95)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Compare float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fcmp<op></p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. A floating-point comparison is performed:<br>If value1 is greater than value2, the int value 1 is pushed onto the operand stack.<br>Otherwise, if value1 is equal to value2, the int value 0 is pushed onto the operand stack.<br>Otherwise, if value1 is less than value2, the int value -1 is pushed onto the operand stack.<br>Otherwise, at least one of value1 or value2 is NaN. The fcmpg instruction pushes the int value 1 onto the operand stack and the fcmpl instruction pushes the int value -1 onto the operand stack.<br>Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fcmpg and fcmpl instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any float comparison fails if either or both of its operands are NaN. With both fcmpg and fcmpl available, any float comparison may be compiled to push the same result onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : fcmpg</p>
<p><span class='InstructionTitle'>Opcode</span> : 150(0x96)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Compare float</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>fcmpg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type float. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. A floating-point comparison is performed:<br>If value1 is greater than value2, the int value 1 is pushed onto the operand stack.<br>Otherwise, if value1 is equal to value2, the int value 0 is pushed onto the operand stack.<br>Otherwise, if value1 is less than value2, the int value -1 is pushed onto the operand stack.<br>Otherwise, at least one of value1 or value2 is NaN. The fcmpg instruction pushes the int value 1 onto the operand stack and the fcmpl instruction pushes the int value -1 onto the operand stack.<br>Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The fcmpg and fcmpl instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any float comparison fails if either or both of its operands are NaN. With both fcmpg and fcmpl available, any float comparison may be compiled to push the same result onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dcmpl</p>
<p><span class='InstructionTitle'>Opcode</span> : 151(0x97)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Compare double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dcmpl</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. A floating-point comparison is performed:<br>If value1 is greater than value2, the int value 1 is pushed onto the operand stack.<br>Otherwise, if value1 is equal to value2, the int value 0 is pushed onto the operand stack.<br>Otherwise, if value1 is less than value2, the int value -1 is pushed onto the operand stack.<br>Otherwise, at least one of value1 or or value2 is NaN. The dcmpg instruction pushes the int value 1 onto the operand stack and the dcmpl instruction pushes the int value -1 onto the operand stack.<br>Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dcmpg and dcmpl instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any double comparison fails if either or both of its operands are NaN. With both dcmpg and dcmpl available, any double comparison may be compiled to push the same result onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dcmpg</p>
<p><span class='InstructionTitle'>Opcode</span> : 152(0x98)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Compare double</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dcmpg</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type double. The values are popped from the operand stack and undergo value set conversion, resulting in value1 and value2. A floating-point comparison is performed:<br>If value1 is greater than value2, the int value 1 is pushed onto the operand stack.<br>Otherwise, if value1 is equal to value2, the int value 0 is pushed onto the operand stack.<br>Otherwise, if value1 is less than value2, the int value -1 is pushed onto the operand stack.<br>Otherwise, at least one of value1 or value2 is NaN. The dcmpg instruction pushes the int value 1 onto the operand stack and the dcmpl instruction pushes the int value -1 onto the operand stack.<br>Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The dcmpg and dcmpl instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any double comparison fails if either or both of its operands are NaN. With both dcmpg and dcmpl available, any double comparison may be compiled to push the same result onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifeq</p>
<p><span class='InstructionTitle'>Opcode</span> : 153(0x99)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifeq</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value = 0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifeq instruction. The target address must be that of an opcode of an instruction within the method that contains this ifeq instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifeq instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifne</p>
<p><span class='InstructionTitle'>Opcode</span> : 154(0x9a)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifne</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value  0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifne instruction. The target address must be that of an opcode of an instruction within the method that contains this ifne instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifne instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : iflt</p>
<p><span class='InstructionTitle'>Opcode</span> : 155(0x9b)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>iflt</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value < 0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this iflt instruction. The target address must be that of an opcode of an instruction within the method that contains this iflt instruction.<br>Otherwise, execution proceeds at the address of the instruction following this iflt instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifge</p>
<p><span class='InstructionTitle'>Opcode</span> : 156(0x9c)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifge</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value  0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifge instruction. The target address must be that of an opcode of an instruction within the method that contains this ifge instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifge instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifgt</p>
<p><span class='InstructionTitle'>Opcode</span> : 157(0x9d)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifgt</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value > 0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifgt instruction. The target address must be that of an opcode of an instruction within the method that contains this ifgt instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifgt instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifle</p>
<p><span class='InstructionTitle'>Opcode</span> : 158(0x9e)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison with zero succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifle</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type int. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:<br>succeeds if and only if value  0<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifle instruction. The target address must be that of an opcode of an instruction within the method that contains this ifle instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifle instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmpeq</p>
<p><span class='InstructionTitle'>Opcode</span> : 159(0x9f)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmpne</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>succeeds if and only if value1   > value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmpeq instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmpeq instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmpeq instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmpne</p>
<p><span class='InstructionTitle'>Opcode</span> : 160(0xa0)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmpne</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>succeeds if and only if value1 != value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmpne instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmp<cond> instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmpne instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmplt</p>
<p><span class='InstructionTitle'>Opcode</span> : 161(0xa1)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmplt</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>lt succeeds if and only if value1 < value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmplt instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmplt instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmplt instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmpge</p>
<p><span class='InstructionTitle'>Opcode</span> : 162(0xa2)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmpge</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>succeeds if and only if value1 >= value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmpge instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmpge instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmpge instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmpgt</p>
<p><span class='InstructionTitle'>Opcode</span> : 163(0xa3)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmpgt></p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>gt succeeds if and only if value1 > value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmpgt instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmpgt instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmpgt instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_icmple</p>
<p><span class='InstructionTitle'>Opcode</span> : 164(0xa4)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if int comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_icmple</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type int. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparison are as follows:<br>succeeds if and only if value1 <= value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_icmple instruction. The target address must be that of an opcode of an instruction within the method that contains this if_icmple instruction.<br>Otherwise, execution proceeds at the address of the instruction following this if_icmple instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_acmpeq</p>
<p><span class='InstructionTitle'>Opcode</span> : 165(0xa5)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if reference comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_acmpeq</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type reference. They are both popped from the operand stack and compared. The results of the comparison are as follows:<br>succeeds if and only if value1 = value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_acmpeq instruction. The target address must be that of an opcode of an instruction within the method that contains this if_acmpeq instruction.<br>Otherwise, if the comparison fails, execution proceeds at the address of the instruction following this if_acmpeq instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : if_acmpne</p>
<p><span class='InstructionTitle'>Opcode</span> : 166(0xa6)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if reference comparison succeeds</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>if_acmpne</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value1, value2  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>Both value1 and value2 must be of type reference. They are both popped from the operand stack and compared. The results of the comparison are as follows:<br>succeeds if and only if value1  value2<br>If the comparison succeeds, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this if_acmpne instruction. The target address must be that of an opcode of an instruction within the method that contains this if_acmpne instruction.<br>Otherwise, if the comparison fails, execution proceeds at the address of the instruction following this if_acmpne instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : goto</p>
<p><span class='InstructionTitle'>Opcode</span> : 167(0xa7)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch always</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>goto</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>No change</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 << 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this goto instruction. The target address must be that of an opcode of an instruction within the method that contains this goto instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : jsr</p>
<p><span class='InstructionTitle'>Opcode</span> : 168(0xa8)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Jump subroutine</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>jsr</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., address</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The address of the opcode of the instruction immediately following this jsr instruction is pushed onto the operand stack as a value of type returnAddress. The unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is (branchbyte1 << 8) | branchbyte2. Execution proceeds at that offset from the address of this jsr instruction. The target address must be that of an opcode of an instruction within the method that contains this jsr instruction.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The jsr instruction is used with the ret instruction in the implementation of the finally clauses of the Java programming language. Note that jsr pushes the address onto the operand stack and ret gets it out of a local variable. This asymmetry is intentional.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ret</p>
<p><span class='InstructionTitle'>Opcode</span> : 169(0xa9)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return from subroutine</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ret</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>No change</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The index is an unsigned byte between 0 and 255, inclusive. The local variable at index in the current frame must contain a value of type returnAddress. The contents of the local variable are written into the Java virtual machines pc register, and execution continues there.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The ret instruction is used with jsr or jsr_w instructions in the implementation of the finally clauses of the Java programming language. Note that jsr pushes the address onto the operand stack and ret gets it out of a local variable. This asymmetry is intentional.<br>The ret instruction should not be confused with the return instruction. A return instruction returns control from a method to its invoker, without passing any value back to the invoker.<br>The ret opcode can be used in conjunction with the wide instruction to access a local variable using a two-byte unsigned index.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : tableswitch</p>
<p><span class='InstructionTitle'>Opcode</span> : 170(0xaa)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Access jump table by index and jump</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>tableswitch</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., index  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>A tableswitch is a variable-length instruction. Immediately after the tableswitch opcode, between 0 and 3 null bytes (zeroed bytes, not the null object) are inserted as padding. The number of null bytes is chosen so that the following byte begins at an address that is a multiple of 4 bytes from the start of the current method (the opcode of its first instruction). Immediately after the padding follow bytes constituting three signed 32-bit values: default, low, and high. Immediately following those bytes are bytes constituting a series of high - low + 1 signed 32-bit offsets. The value low must be less than or equal to high. The high - low + 1 signed 32-bit offsets are treated as a 0-based jump table. Each of these signed 32-bit values is constructed as (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4.<br>The index must be of type int and is popped from the operand stack. If index is less than low or index is greater than high, then a target address is calculated by adding default to the address of the opcode of this tableswitch instruction. Otherwise, the offset at position index - low of the jump table is extracted. The target address is calculated by adding that offset to the address of the opcode of this tableswitch instruction. Execution then continues at the target address.<br>The target address that can be calculated from each jump table offset, as well as the ones that can be calculated from default, must be the address of an opcode of an instruction within the method that contains this tableswitch instruction.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The alignment required of the 4-byte operands of the tableswitch instruction guarantees 4-byte alignment of those operands if and only if the method that contains the tableswitch starts on a 4-byte boundary.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lookupswitch</p>
<p><span class='InstructionTitle'>Opcode</span> : 171(0xab)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Access jump table by key match and jump</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lookupswitch</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., key  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>A lookupswitch is a variable-length instruction. Immediately after the lookupswitch opcode, between zero and three null bytes (zeroed bytes, not the null object) are inserted as padding. The number of null bytes is chosen so that the defaultbyte1 begins at an address that is a multiple of four bytes from the start of the current method (the opcode of its first instruction). Immediately after the padding follow a series of signed 32-bit values: default, npairs, and then npairs pairs of signed 32-bit values. The npairs must be greater than or equal to 0. Each of the npairs pairs consists of an int match and a signed 32-bit offset. Each of these signed 32-bit values is constructed from four unsigned bytes as (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4.<br>The table match-offset pairs of the lookupswitch instruction must be sorted in increasing numerical order by match.<br>The key must be of type int and is popped from the operand stack. The key is compared against the match values. If it is equal to one of them, then a target address is calculated by adding the corresponding offset to the address of the opcode of this lookupswitch instruction. If the key does not match any of the match values, the target address is calculated by adding default to the address of the opcode of this lookupswitch instruction. Execution then continues at the target address.<br>The target address that can be calculated from the offset of each match-offset pair, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this lookupswitch instruction.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The alignment required of the 4-byte operands of the lookupswitch instruction guarantees 4-byte alignment of those operands if and only if the method that contains the lookupswitch is positioned on a 4-byte boundary.<br>The match-offset pairs are sorted to support lookup routines that are quicker than linear search.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ireturn</p>
<p><span class='InstructionTitle'>Opcode</span> : 172(0xac)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return int from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ireturn</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The current method must have return type boolean, byte, short, char, or int. The value must be of type int. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, value is popped from the operand stack of the current frame and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, ireturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then ireturn throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : lreturn</p>
<p><span class='InstructionTitle'>Opcode</span> : 173(0xad)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return long from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>lreturn</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The current method must have return type long. The value must be of type long. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, value is popped from the operand stack of the current frame and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, lreturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then lreturn throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : freturn</p>
<p><span class='InstructionTitle'>Opcode</span> : 174(0xae)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return float from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>freturn</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The current method must have return type float. The value must be of type float. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, value is popped from the operand stack of the current frame and undergoes value set conversion, resulting in value. The value is pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, freturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then freturn throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : dreturn</p>
<p><span class='InstructionTitle'>Opcode</span> : 175(0xaf)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return double from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>dreturn</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The current method must have return type double. The value must be of type double. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, value is popped from the operand stack of the current frame and undergoes value set conversion, resulting in value. The value is pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, dreturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then dreturn throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : areturn</p>
<p><span class='InstructionTitle'>Opcode</span> : 176(0xb0)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return reference from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>areturn</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref must be of type reference and must refer to an object of a type that is assignment compatible with the type represented by the return descriptor of the current method. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, objectref is popped from the operand stack of the current frame and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>The interpreter then reinstates the frame of the invoker and returns control to the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, areturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then areturn throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : return</p>
<p><span class='InstructionTitle'>Opcode</span> : 177(0xb1)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Return void from method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>return</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  [empty]</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The current method must have return type void. If the current method is a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. If no exception is thrown, any values on the operand stack of the current frame are discarded.<br>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the current method is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, return throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the first of those rules is violated during invocation of the current method, then return throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : getstatic</p>
<p><span class='InstructionTitle'>Opcode</span> : 178(0xb2)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Get static field from class</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>getstatic</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...,  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a field, which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found. The referenced field is resolved.<br>On successful resolution of the field, the class or interface that declared the resolved field is initialized if that class or interface has not already been initialized.<br>The value of the class or interface field is fetched and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution documented in Section 5.4.3.2 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved field is not a static (class) field or an interface field, getstatic throws an IncompatibleClassChangeError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if execution of this getstatic instruction causes initialization of the referenced class or interface, getstatic may throw an Error as detailed in Section 2.17.5 of Java Virtual Machine Specification.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : putstatic</p>
<p><span class='InstructionTitle'>Opcode</span> : 179(0xb3)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Set static field in class</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>putstatic</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a field, which gives the name and descriptor of the field as well as a symbolic reference to the class or interface in which the field is to be found. The referenced field is resolved.<br>On successful resolution of the field the class or interface that declared the resolved field is initialized if that class or interface has not already been initialized.<br>The type of a value stored by a putstatic instruction must be compatible with the descriptor of the referenced field. If the field descriptor type is boolean, byte, char, short, or int, then the value must be an int. If the field descriptor type is float, long, or double, then the value must be a float, long, or double, respectively. If the field descriptor type is a reference type, then the value must be of a type that is assignment compatible with the field descriptor type. If the field is final, it should be declared in the current class. Otherwise, an IllegalAccessError is thrown.<br>The value is popped from the operand stack and undergoes value set conversion, resulting in value. The class field is set to value.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class or interface field, any of the exceptions pertaining to field resolution documented in Section 5.4.3.2 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved field is not a static (class) field or an interface field, putstatic throws an IncompatibleClassChangeError.<br>Otherwise, if the field is final, it must be declared in the current class. Otherwise, an IllegalAccessError is thrown.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if execution of this putstatic instruction causes initialization of the referenced class or interface, putstatic may throw an Error as detailed in Section 2.17.5 of Java Virtual Machine Specification.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>A putstatic instruction may be used only to set the value of an interface field on the initialization of that field. Interface fields may be assigned to only once, on execution of an interface variable initialization expression when the interface is initialized.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : getfield</p>
<p><span class='InstructionTitle'>Opcode</span> : 180(0xb4)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Fetch field from object</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>getfield</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ..., value</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref, which must be of type reference, is popped from the operand stack. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a field, which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found. The referenced field is resolved. The value of the referenced field in objectref is fetched and pushed onto the operand stack.<br>The class of objectref must not be an array. If the field is protected, and it is either a member of the current class or a member of a superclass of the current class, then the class of objectref must be either the current class or a subclass of the current class.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the field, any of the errors pertaining to field resolution documented in Section 5.4.3.2 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved field is a static field, getfield throws an IncompatibleClassChangeError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref is null, the getfield instruction throws a NullPointerException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The getfield instruction cannot be used to access the length field of an array. The arraylength instruction is used instead.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : putfield</p>
<p><span class='InstructionTitle'>Opcode</span> : 181(0xb5)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Set field in object</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>putfield</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref, value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a field, which gives the name and descriptor of the field as well as a symbolic reference to the class in which the field is to be found. The class of objectref must not be an array. If the field is protected, and it is either a member of the current class or a member of a superclass of the current class, then the class of objectref must be either the current class or a subclass of the current class.<br>The referenced field is resolved. The type of a value stored by a putfield instruction must be compatible with the descriptor of the referenced field. If the field descriptor type is boolean, byte, char, short, or int, then the value must be an int. If the field descriptor type is float, long, or double, then the value must be a float, long, or double, respectively. If the field descriptor type is a reference type, then the value must be of a type that is assignment compatible with the field descriptor type. If the field is final, it should be declared in the current class. Otherwise, an IllegalAccessError is thrown.<br>The value and objectref are popped from the operand stack. The objectref must be of type reference. The value undergoes value set conversion, resulting in value, and the referenced field in objectref is set to value.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the field, any of the exceptions pertaining to field resolution documented in Section 5.4.3.2 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved field is a static field, putfield throws an IncompatibleClassChangeError.<br>Otherwise, if the field is final, it must be declared in the current class. Otherwise, an IllegalAccessError is thrown.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref is null, the putfield instruction throws a NullPointerException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : invokevirtual</p>
<p><span class='InstructionTitle'>Opcode</span> : 182(0xb6)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Invoke instance method; dispatch based on class</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>invokevirtual</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref, [arg1, [arg2 ...]]  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a method, which gives the name and descriptor of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved. The method must not be an instance initialization method or the class or interface initialization method. Finally, if the resolved method is protected, and it is either a member of the current class or a member of a superclass of the current class, then the class of objectref must be either the current class or a subclass of the current class.<br>Let C be the class of objectref. The actual method to be invoked is selected by the following lookup procedure:<br>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, and the resolved method is accessible from C, then this is the method to be invoked, and the lookup procedure terminates.<br>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C ; the method to be invoked is the result of the recursive invocation of this lookup procedure.<br>Otherwise, an AbstractMethodError is raised.<br>The objectref must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.<br>If the method is synchronized, the monitor associated with objectref is acquired or reentered.<br>If the method is not native, the nargs argument values and objectref are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The objectref and the argument values are consecutively made the values of local variables of the new frame, with objectref in local variable 0, arg1 in local variable 1 (or, if arg1 is of type long or double, in local variables 1 and 2), and so on. Any argument value that is of a floating-point type undergoes value set conversion prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<br>If the method is native and the platform-dependent code that implements it has not yet been bound into the Java virtual machine, that is done. The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:<br>If the native method is synchronized, the monitor associated with objectref is released or exited as if by execution of a monitorexit instruction.<br>If the native method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the native method and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in Section 5.4.3.3 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved method is a class (static) method, the invokevirtual instruction throws an IncompatibleClassChangeError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref is null, the invokevirtual instruction throws a NullPointerException.<br>Otherwise, if no method matching the resolved name and descriptor is selected, invokevirtual throws an AbstractMethodError.<br>Otherwise, if the selected method is abstract, invokevirtual throws an AbstractMethodError.<br>Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokevirtual throws an UnsatisfiedLinkError.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : invokespecial</p>
<p><span class='InstructionTitle'>Opcode</span> : 183(0xb7)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Invoke instance method; special handling for superclass, private, and instance initialization method invocations</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>invokespecial</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref, [arg1, [arg2 ...]]  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a method, which gives the name and descriptor of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved. Finally, if the resolved method is protected, and it is either a member of the current class or a member of a superclass of the current class, then the class of objectref must be either the current class or a subclass of the current class.<br>Next, the resolved method is selected for invocation unless all of the following conditions are true:<br>The ACC_SUPER flag (see Table 4.1, "Class access and property modifiers") is set for the current class.<br>The class of the resolved method is a superclass of the current class.<br>The resolved method is not an instance initialization method.<br>If the above conditions are true, the actual method to be invoked is selected by the following lookup procedure. Let C be the direct superclass of the current class:<br>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this method will be invoked. The lookup procedure terminates.<br>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C. The method to be invoked is the result of the recursive invocation of this lookup procedure.<br>Otherwise, an AbstractMethodError is raised.<br>The objectref must be of type reference and must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the selected instance method.<br>If the method is synchronized, the monitor associated with objectref is acquired or reentered.<br>If the method is not native, the nargs argument values and objectref are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The objectref and the argument values are consecutively made the values of local variables of the new frame, with objectref in local variable 0, arg1 in local variable 1 (or, if arg1 is of type long or double, in local variables 1 and 2), and so on. Any argument value that is of a floating-point type undergoes value set conversion prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<br>If the method is native and the platform-dependent code that implements it has not yet been bound into the Java virtual machine, that is done. The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:<br>If the native method is synchronized, the monitor associated with objectref is released or exited as if by execution of a monitorexit instruction.<br>If the native method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the native method and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in Section 5.4.3.3 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved method is an instance initialization method, and the class in which it is declared is not the class symbolically referenced by the instruction, a NoSuchMethodError is thrown.<br>Otherwise, if the resolved method is a class (static) method, the invokespecial instruction throws an IncompatibleClassChangeError.<br>Otherwise, if no method matching the resolved name and descriptor is selected, invokespecial throws an AbstractMethodError.<br>Otherwise, if the selected method is abstract, invokespecial throws an AbstractMethodError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref is null, the invokespecial instruction throws a NullPointerException.<br>Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokespecial throws an UnsatisfiedLinkError.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : invokestatic</p>
<p><span class='InstructionTitle'>Opcode</span> : 184(0xb8)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Invoke a class (static) method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>invokestatic</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., [arg1, [arg2 ...]]  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a method, which gives the name and descriptor of the method as well as a symbolic reference to the class in which the method is to be found. The named method is resolved. The method must not be the class or interface initialization method. It must be static, and therefore cannot be abstract.<br>On successful resolution of the method, the class that declared the resolved field is initialized if that class has not already been initialized.<br>The operand stack must contain nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved method.<br>If the method is synchronized, the monitor associated with the resolved class is acquired or reentered.<br>If the method is not native, the nargs argument values are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The nargs argument values are consecutively made the values of local variables of the new frame, with arg1 in local variable 0 (or, if arg1 is of type long or double, in local variables 0 and 1) and so on. Any argument value that is of a floating-point type undergoes value set conversion prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<br>If the method is native and the platform-dependent code that implements it has not yet been bound into the Java virtual machine, that is done. The nargs argument values are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns, the following take place:<br>If the native method is synchronized, the monitor associated with the resolved class is released or exited as if by execution of a monitorexit instruction.<br>If the native method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the native method and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the method, any of the exceptions pertaining to method resolution documented in Section 5.4.3.3 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the resolved method is an instance method, the invokestatic instruction throws an IncompatibleClassChangeError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if execution of this invokestatic instruction causes initialization of the referenced class, invokestatic may throw an Error as detailed in Section 2.17.5 of Java Virtual Machine Specification.<br>Otherwise, if the resolved method is native and the code that implements the method cannot be bound, invokestatic throws an UnsatisfiedLinkError.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : invokeinterface</p>
<p><span class='InstructionTitle'>Opcode</span> : 185(0xb9)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Invoke interface method</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>invokeinterface</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref, [arg1, [arg2 ...]]  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to an interface method, which gives the name and descriptor of the interface method as well as a symbolic reference to the interface in which the interface method is to be found. The named interface method is resolved. The interface method must not be an instance initialization method or the class or interface initialization method.<br>The count operand is an unsigned byte that must not be zero. The objectref must be of type reference and must be followed on the operand stack by nargs argument values, where the number, type, and order of the values must be consistent with the descriptor of the resolved interface method. The value of the fourth operand byte must always be zero.<br>Let C be the class of objectref. The actual method to be invoked is selected by the following lookup procedure:<br>If C contains a declaration for an instance method with the same name and descriptor as the resolved method, then this is the method to be invoked, and the lookup procedure terminates.<br>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.<br>Otherwise, an AbstractMethodError is raised.<br>If the method is synchronized, the monitor associated with objectref is acquired or reentered.<br>If the method is not native, the nargs argument values and objectref are popped from the operand stack. A new frame is created on the Java virtual machine stack for the method being invoked. The objectref and the argument values are consecutively made the values of local variables of the new frame, with objectref in local variable 0, arg1 in local variable 1 (or, if arg1 is of type long or double, in local variables 1 and 2), and so on. Any argument value that is of a floating-point type undergoes value set conversion prior to being stored in a local variable. The new frame is then made current, and the Java virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<br>If the method is native and the platform-dependent code that implements it has not yet been bound into the Java virtual machine, that is done. The nargs argument values and objectref are popped from the operand stack and are passed as parameters to the code that implements the method. Any argument value that is of a floating-point type undergoes value set conversion prior to being passed as a parameter. The parameters are passed and the code is invoked in an implementation-dependent manner. When the platform-dependent code returns:<br>If the native method is synchronized, the monitor associated with objectref is released or exited as if by execution of a monitorexit instruction.<br>If the native method returns a value, the return value of the platform-dependent code is converted in an implementation-dependent way to the return type of the native method and pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the interface method, any of the exceptions documented in Section 5.4.3.4 of Java Virtual Machine Specification can be thrown.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref is null, the invokeinterface instruction throws a NullPointerException.<br>Otherwise, if the class of objectref does not implement the resolved interface, invokeinterface throws an IncompatibleClassChangeError.<br>Otherwise, if no method matching the resolved name and descriptor is selected, invokeinterface throws an AbstractMethodError.<br>Otherwise, if the selected method is not public, invokeinterface throws an IllegalAccessError.<br>Otherwise, if the selected method is abstract, invokeinterface throws an AbstractMethodError.<br>Otherwise, if the selected method is native and the code that implements the method cannot be bound, invokeinterface throws an UnsatisfiedLinkError.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : new</p>
<p><span class='InstructionTitle'>Opcode</span> : 187(0xbb)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Create new object</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>new</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved and should result in a class type (it should not result in an array or interface type). Memory for a new instance of that class is allocated from the garbage-collected heap, and the instance variables of the new object are initialized to their default initial values. The objectref, a reference to the instance, is pushed onto the operand stack.<br>On successful resolution of the class, it is initialized if it has not already been initialized.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in Section 5.4.3.1 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the symbolic reference to the class, array, or interface type resolves to an interface or is an abstract class, new throws an InstantiationError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if execution of this new instruction causes initialization of the referenced class, new may throw an Error as detailed in Section 2.17.5 of Java Virtual Machine Specification.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The new instruction does not completely create a new instance; instance creation is not completed until an instance initialization method has been invoked on the uninitialized instance.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : newarray</p>
<p><span class='InstructionTitle'>Opcode</span> : 188(0xbc)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Create new array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>newarray</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., count  ..., arrayref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The count must be of type int. It is popped off the operand stack. The count represents the number of elements in the array to be created.<br>The atype is a code that indicates the type of array to create. It must take one of the following values:<br>Array Type  atype<br>T_BOOLEAN  4<br>T_CHAR  5<br>T_FLOAT  6<br>T_DOUBLE  7<br>T_BYTE  8<br>T_SHORT  9<br>T_INT  10<br>T_LONG  11<br>A new array whose components are of type atype and of length count is allocated from the garbage-collected heap. A reference arrayref to this new array object is pushed into the operand stack. Each of the elements of the new array is initialized to the default initial value for the type of the array.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If count is less than zero, newarray throws a NegativeArraySizeException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>In Suns implementation of the Java virtual machine, arrays of type boolean (atype is T_BOOLEAN) are stored as arrays of 8-bit values and are manipulated using the baload and bastore instructions, instructions that also access arrays of type byte. Other implementations may implement packed boolean arrays; the baload and bastore instructions must still be used to access those arrays.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : anewarray</p>
<p><span class='InstructionTitle'>Opcode</span> : 189(0xbd)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Create new array of reference</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>anewarray</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., count  ..., arrayref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The count must be of type int. It is popped off the operand stack. The count represents the number of components of the array to be created. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at that index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved. A new array with components of that type, of length count, is allocated from the garbage-collected heap, and a reference arrayref to this new array object is pushed onto the operand stack. All components of the new array are initialized to null, the default value for reference types.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in Section 5.4.3.1 of Java Virtual Machine Specification can be thrown.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if count is less than zero, the anewarray instruction throws a NegativeArraySizeException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The anewarray instruction is used to create a single dimension of an array of object references or part of a multidimensional array.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : arraylength</p>
<p><span class='InstructionTitle'>Opcode</span> : 190(0xbe)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Get length of array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>arraylength</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., arrayref  ..., length</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The arrayref must be of type reference and must refer to an array. It is popped from the operand stack. The length of the array it references is determined. That length is pushed onto the operand stack as an int.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If the arrayref is null, the arraylength instruction throws a NullPointerException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : athrow</p>
<p><span class='InstructionTitle'>Opcode</span> : 191(0xbf)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Throw exception or error</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>athrow</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref must be of type reference and must refer to an object that is an instance of class Throwable or of a subclass of Throwable. It is popped from the operand stack. The objectref is then thrown by searching the current method for the first exception handler that matches the class of objectref, as given by the algorithm in Section 3.10 of Java Virtual Machine Specification.<br>If an exception handler that matches objectref is found, it contains the location of the code intended to handle this exception. The pc register is reset to that location, the operand stack of the current frame is cleared, objectref is pushed back onto the operand stack, and execution continues.<br>If no matching exception handler is found in the current frame, that frame is popped. If the current frame represents an invocation of a synchronized method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a monitorexit instruction. Finally, the frame of its invoker is reinstated, if such a frame exists, and the objectref is rethrown. If no such frame exists, the current thread exits.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If objectref is null, athrow throws a NullPointerException instead of objectref.<br>Otherwise, if the method of the current frame is a synchronized method and the current thread is not the owner of the monitor acquired or reentered on invocation of the method, athrow throws an IllegalMonitorStateException instead of the object previously being thrown. This can happen, for example, if an abruptly completing synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Sepcification and if the first of those rules is violated during invocation of the current method, then athrow throws an IllegalMonitorStateException instead of the object previously being thrown.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : checkcast</p>
<p><span class='InstructionTitle'>Opcode</span> : 192(0xc0)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Check whether object is of given type</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>checkcast</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ..., objectref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref must be of type reference. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved.<br>If objectref is null or can be cast to the resolved class, array, or interface type, the operand stack is unchanged; otherwise, the checkcast instruction throws a ClassCastException.<br>The following rules are used to determine whether an objectref that is not null can be cast to the resolved type: if S is the class of the object referred to by objectref and T is the resolved class, array, or interface type, checkcast determines whether objectref can be cast to type T as follows:<br>If S is an ordinary (nonarray) class, then:<br>If T is a class type, then S must be the same class as T, or a subclass of T.<br>If T is an interface type, then S must implement interface T.<br>If S is an interface type, then:<br>If T is a class type, then T must be Object.<br>If T is an interface type, then T must be the same interface as S or a superinterface of S.<br>If S is a class representing the array type SC[], that is, an array of components of type SC, then:<br>If T is a class type, then T must be Object.<br>If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:<br>TC and SC are the same primitive type.<br>TC and SC are reference types, and type SC can be cast to TC by recursive application of these rules.<br>If T is an interface type, T must be one of the interfaces implemented by arrays.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in Section 5.4.3.1 of Java Virtual Machine Specification can be thrown.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if objectref cannot be cast to the resolved class, array, or interface type, the checkcast instruction throws a ClassCastException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The checkcast instruction is very similar to the instanceof instruction. It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : instanceof</p>
<p><span class='InstructionTitle'>Opcode</span> : 193(0xc1)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Determine if object is of given type</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>instanceof</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ..., result</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref, which must be of type reference, is popped from the operand stack. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved.<br>If objectref is not null and is an instance of the resolved class or array or implements the resolved interface, the instanceof instruction pushes an int result of 1 as an int on the operand stack. Otherwise, it pushes an int result of 0.<br>The following rules are used to determine whether an objectref that is not null is an instance of the resolved type: If S is the class of the object referred to by objectref and T is the resolved class, array, or interface type, instanceof determines whether objectref is an instance of T as follows:<br>If S is an ordinary (nonarray) class, then:<br>If T is a class type, then S must be the same class as T or a subclass of T.<br>If T is an interface type, then S must implement interface T.<br>If S is an interface type, then:<br>If T is a class type, then T must be Object.<br>If T is an interface type, then T must be the same interface as S, or a superinterface of S.<br>If S is a class representing the array type SC[], that is, an array of components of type SC, then:<br>If T is a class type, then T must be Object.<br>If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:<br>TC and SC are the same primitive type.<br>TC and SC are reference types, and type SC can be cast to TC by these runtime rules.<br>If T is an interface type, T must be one of the interfaces implemented by arrays.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of symbolic reference to the class, array, or interface type, any of the exceptions documented in Section 5.4.3.1 of Java Virtual Machine Specification can be thrown.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The instanceof instruction is very similar to the checkcast instruction. It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : monitorenter</p>
<p><span class='InstructionTitle'>Opcode</span> : 194(0xc2)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Enter monitor for object</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>monitorenter</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref must be of type reference.<br>Each object has a monitor associated with it. The thread that executes monitorenter gains ownership of the monitor associated with objectref. If another thread already owns the monitor associated with objectref, the current thread waits until the object is unlocked, then tries again to gain ownership. If the current thread already owns the monitor associated with objectref, it increments a counter in the monitor indicating the number of times this thread has entered the monitor. If the monitor associated with objectref is not owned by any thread, the current thread becomes the owner of the monitor, setting the entry count of this monitor to 1.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If objectref is null, monitorenter throws a NullPointerException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>For detailed information about threads and monitors in the Java virtual machine, see Chapter 8 of the Java Virtual Machine Specification, "Threads and Locks."<br>A monitorenter instruction may be used with one or more monitorexit instructions to implement a synchronized statement in the Java programming language. The monitorenter and monitorexit instructions are not used in the implementation of synchronized methods, although they can be used to provide equivalent locking semantics; however, monitor entry on invocation of a synchronized method is handled implicitly by the Java virtual machines method invocation instructions. See Section 7.14 of Java Virtual Machine Specification for more information on the use of the monitorenter and monitorexit instructions.<br>The association of a monitor with an object may be managed in various ways that are beyond the scope of this specification. For instance, the monitor may be allocated and deallocated at the same time as the object. Alternatively, it may be dynamically allocated at the time when a thread attempts to gain exclusive access to the object and freed at some later time when no thread remains in the monitor for the object.<br>The synchronization constructs of the Java programming language require support for operations on monitors besides entry and exit. These include waiting on a monitor (Object.wait) and notifying other threads waiting on a monitor (Object.notifyAll and Object.notify). These operations are supported in the standard package java.lang supplied with the Java virtual machine. No explicit support for these operations appears in the instruction set of the Java virtual machine.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : monitorexit</p>
<p><span class='InstructionTitle'>Opcode</span> : 195(0xc3)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Exit monitor for object</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>monitorexit</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., objectref  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The objectref must be of type reference.<br>The current thread should be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the counter indicating the number of times it has entered this monitor. If as a result the value of the counter becomes zero, the current thread releases the monitor. If the monitor associated with objectref becomes free, other threads that are waiting to acquire that monitor are allowed to attempt to do so.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>If objectref is null, monitorexit throws a NullPointerException.<br>Otherwise, if the current thread is not the owner of the monitor, monitorexit throws an IllegalMonitorStateException.<br>Otherwise, if the virtual machine implementation enforces the rules on structured use of locks described in Section 8.13 of Java Virtual Machine Specification and if the second of those rules is violated by the execution of this monitorexit instruction, then monitorexit throws an IllegalMonitorStateException.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : wide</p>
<p><span class='InstructionTitle'>Opcode</span> : 196(0xc4)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Extend local variable index by additional bytes</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>Format 1<br>wide   <br><opcode>   <br>indexbyte1   <br>indexbyte2   <br><br>where <opcode> is one of iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret<br><br>Format 2<br>wide   <br>iinc   <br>indexbyte1   <br>indexbyte2   <br>constbyte1   <br>constbyte2</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>Same as modified instruction</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The wide instruction modifies the behavior of another instruction. It takes one of two formats, depending on the instruction being modified. The first form of the wide instruction modifies one of the instructions iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret. The second form applies only to the iinc instruction.<br>In either case, the wide opcode itself is followed in the compiled code by the opcode of the instruction wide modifies. In either form, two unsigned bytes indexbyte1 and indexbyte2 follow the modified opcode and are assembled into a 16-bit unsigned index to a local variable in the current frame, where the value of the index is<br>(indexbyte1 << 8) | indexbyte2. The calculated index must be an index into the local variable array of the current frame. Where the wide instruction modifies an lload, dload, lstore, or dstore instruction, the index following the calculated index (index + 1) must also be an index into the local variable array. In the second form, two immediate unsigned bytes constbyte1 and constbyte2 follow indexbyte1 and indexbyte2 in the code stream. Those bytes are also assembled into a signed 16-bit constant, where the constant is (constbyte1 << 8) | constbyte2.<br>The widened bytecode operates as normal, except for the use of the wider index and, in the case of the second form, the larger increment range.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>Although we say that wide "modifies the behavior of another instruction," the wide instruction effectively treats the bytes constituting the modified instruction as operands, denaturing the embedded instruction in the process. In the case of a modified iinc instruction, one of the logical operands of the iinc is not even at the normal offset from the opcode. The embedded instruction must never be executed directly; its opcode must never be the target of any control transfer instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : multianewarray</p>
<p><span class='InstructionTitle'>Opcode</span> : 197(0xc5)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Create new multidimensional array</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>multianewarray</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., count1, [count2, ...]  ..., arrayref</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The dimensions operand is an unsigned byte that must be greater than or equal to 1. It represents the number of dimensions of the array to be created. The operand stack must contain dimensions values. Each such value represents the number of components in a dimension of the array to be created, must be of type int, and must be nonnegative. The count1 is the desired length in the first dimension, count2 in the second, etc.<br>All of the count values are popped off the operand stack. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the runtime constant pool of the current class, where the value of the index is (indexbyte1 << 8) | indexbyte2. The runtime constant pool item at the index must be a symbolic reference to a class, array, or interface type. The named class, array, or interface type is resolved. The resulting entry must be an array class type of dimensionality greater than or equal to dimensions.<br>A new multidimensional array of the array type is allocated from the garbage-collected heap. If any count value is zero, no subsequent dimensions are allocated. The components of the array in the first dimension are initialized to subarrays of the type of the second dimension, and so on. The components of the last allocated dimension of the array are initialized to the default initial value for the type of the components. A reference arrayref to the new array is pushed onto the operand stack.</p>
<p><span class='InstructionTitle'>Linking Exceptions</span> : </p>
<p>During resolution of the symbolic reference to the class, array, or interface type, any of the exceptions documented in Section 5.4.3.1 of Java Virtual Machine Specification can be thrown.<br>Otherwise, if the current class does not have permission to access the element type of the resolved array class, multianewarray throws an IllegalAccessError.</p>
<p><span class='InstructionTitle'>Runtime Exceptions</span> : </p>
<p>Otherwise, if any of the dimensions values on the operand stack are less than zero, the multianewarray instruction throws a NegativeArraySizeException.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>It may be more efficient to use newarray or anewarray when creating an array of a single dimension.<br>The array class referenced via the runtime constant pool may have more dimensions than the dimensions operand of the multianewarray instruction. In that case, only the first dimensions of the dimensions of the array are created.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifnull</p>
<p><span class='InstructionTitle'>Opcode</span> : 198(0xc6)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if reference is null</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifnull</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must of type reference. It is popped from the operand stack. If value is null, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifnull instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnull instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifnull instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : ifnonnull</p>
<p><span class='InstructionTitle'>Opcode</span> : 199(0xc7)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch if reference not null</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>ifnonnull</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>..., value  ...</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The value must be of type reference. It is popped from the operand stack. If value is not null, the unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is calculated to be (branchbyte1 << 8) | branchbyte2. Execution then proceeds at that offset from the address of the opcode of this ifnonnull instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnonnull instruction.<br>Otherwise, execution proceeds at the address of the instruction following this ifnonnull instruction.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : goto_w</p>
<p><span class='InstructionTitle'>Opcode</span> : 200(0xc8)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Branch always (wide index)</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>goto_w</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>No change</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The unsigned bytes branchbyte1, branchbyte2, branchbyte3, and branchbyte4 are used to construct a signed 32-bit branchoffset, where branchoffset is (branchbyte1 << 24) | (branchbyte2 << 16) | (branchbyte3 << 8) | branchbyte4. Execution proceeds at that offset from the address of the opcode of this goto_w instruction. The target address must be that of an opcode of an instruction within the method that contains this goto_w instruction.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>Although the goto_w instruction takes a 4-byte branch offset, other factors limit the size of a method to 65535 bytes. This limit may be raised in a future release of the Java virtual machine.</p>
<br>
<hr>
<p><span class='InstructionTitle'>Name</span> : jsr_w</p>
<p><span class='InstructionTitle'>Opcode</span> : 201(0xc9)</p>
<p><span class='InstructionTitle'>Operation</span> : </p>
<p>Jump subroutine (wide index)</p>
<p><span class='InstructionTitle'>Format</span> : </p>
<p>jsr_w</p>
<p><span class='InstructionTitle'>Operand Stack</span> : </p>
<p>...  ..., address</p>
<p><span class='InstructionTitle'>Description</span> :</p>
<p>The address of the opcode of the instruction immediately following this jsr_w instruction is pushed onto the operand stack as a value of type returnAddress. The unsigned branchbyte1, branchbyte2, branchbyte3, and branchbyte4 are used to construct a signed 32-bit offset, where the offset is (branchbyte1 << 24) | (branchbyte2 << 16) | (branchbyte3 << 8) | branchbyte4. Execution proceeds at that offset from the address of this jsr_w instruction. The target address must be that of an opcode of an instruction within the method that contains this jsr_w instruction.</p>
 <p><span class='InstructionTitle'>Notes</span> : </p>
<p>The jsr_w instruction is used with the ret instruction in the implementation of the finally clauses of the Java programming language. Note that jsr_w pushes the address onto the operand stack and ret gets it out of a local variable. This asymmetry is intentional.<br>Although the jsr_w instruction takes a 4-byte branch offset, other factors limit the size of a method to 65535 bytes. This limit may be raised in a future release of the Java virtual machine.</p>
<br>
<hr>

<!-- InstanceEndEditable --></td>
  </tr>
  <tr>
  <td colspan="2" align="center">
  <hr>
    <span class="STYLE3">Copyright 2006 - <a href="mailto:yang.jiang.z@gmail.com">Jiang Yang</a> , All Rights Reserved    </span></td>
  </tr>
</table>
</body>
<!-- InstanceEnd --></html>
